<html>

<head>
    <title>Gröbner Solitaire</title>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <link href="../pagestyle.css" type="text/css" rel="stylesheet">

</head>
<body onload="go()">

<div>
    <h1><div id="welcome"></div></h1>
    <div id="geogebra_loading"></div>
    <div id="geogebra_loaded" hidden="true">
    </div>
    <div id="check_button" hidden="true">
        <p><button id="check_solution" type="button" onclick="check_solution()"></button></p>
    </div>
    <div id="applet_container"></div>
    <div id="phase"></div>
    <div id="info"></div>
</div>

<script type="text/javascript" src="deployggb.js"></script>
<script type="text/javascript" src="sprintf.js"></script>

<script type='text/javascript'>

    startup = "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";

    MessageEnum = {
        WELCOME: 0, PLEASE_WAIT: 1, DESCRIPTION: 2, CHECK_BUTTON: 3, PROGRAM_INFO: 4, GEOGEBRA_VERSION: 5,
        NOTHING_GENERATED: 6, ALREADY_EXISTS: 7, NEW_SEGMENT: 8, UNFINISHED: 9, FINISHED: 10
        };

    // https://css-tricks.com/snippets/javascript/get-url-variables/
    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            if (pair[0] == variable) {
                return pair[1];
            }
        }
        return false;
    }


    function go() {

        running = false;

        var lang = getQueryVariable("lang");
        if (!lang) {
            lang = "English";
            }

        // 0. Internationalize initial texts
        if (lang === "English") {
            messages = [ "Welcome to the Gröbner Solitaire!",
                "Please wait for GeoGebra to load...",
                "Consider this initial position of the segments. Try to obtain the final position.",
                "Check solution",
                "This web app was programmed by <a %1$s>%2$s</a> based on the game described in <a %3$s>an article</a> by %4$s and <a %5$s>%6$s</a>.",
                "Using GeoGebra %1$s.",
                "No segment is generated in this way, just a point, because the green and red segments are congruent. Please try again and generate a new green segment.",
                "The segment you obtained already exists as a red segment. Too bad! Please try again and generate a new green segment.",
                "Great! You created a new segment since no further reduction is possible for the green segment.",
                "Sorry, you did not find the final position yet! Please continue.",
                "Great! You found the final position. You win."
                ];
            phase_text = ["Generation phase 1: Select two red segments and click on the blue area to generate a green segment.",
                "Generation phase 2: Finalize the generated green segment by clicking on it.",
                "Reduction phase 1: Keep the green segment selected and reduce it by a red segment by clicking on it, then click on the blue area for reduction.",
                "Reduction phase 2: Confirm the reduced green segment by clicking on it."
                ];
            }

        if (lang === "Hungarian") {
            messages = [ "Köszöntünk a Gröbner Solitaire játékban!",
                "A GeoGebra betöltése folyamatban...",
                "A játéktáblán néhány szakaszt látsz. Keresd meg a végső pozíciójukat!",
                "A megoldás ellenőrzése",
                "Ezt a webalkalmazást <a %1$s>Kovács Zoltán</a> készítette. A program egy %4$s és <a %5$s>%6$s</a> által írt <a %3$s>matematikai tárgyú cikkben</a> bemutatott játékon alapul.",
                "A GeoGebra %1$s verziójának betöltése sikerült.",
                "Nem keletkezett szakasz ily módon, csupán egy pont, mivel a zöld és piros szakaszok eltolással egymásba vihetők. Próbáld újra egy új zöld szakasz létrehozásával!",
                "A kapott szakasz már létezik mint piros szakasz. Kár! Próbáld újra egy új zöld szakasz létrehozásával!",
                "Nagyszerű! Sikerült létrehoznod egy új szakaszt, mivel a zöld szakasz tovább már nem egyszerűsíthető.",
                "Sajnos ez még nem a végső pozíció! Kérlek folytasd a játékot tovább!",
                "Nagyszerű! Megtaláltad a végső pozíciót. Nyertél!"
                ];
            phase_text = ["Létrehozás, 1. lépés: Válassz két piros szakaszt és kattints a kék területre! Így létrehozhatsz egy zöld szakaszt.",
                "Létrehozás, 2. lépés: Rögzítsd a zöld szakaszt úgy, hogy rákattintasz.",
                "Egyszerűsítés, 1. lépés: Legyen a zöld szakasz kiválasztva, és egyszerűsítsd a zöld szakaszt egy piros szakasszal (kattints rá), majd kattints a létrejövő kék területre.",
                "Egyszerűsítés, 2. lépés: Rögzítsd a zöld szakaszt úgy, hogy rákattintasz."
                ];
            }

        if (lang === "German") {
            messages = [ "Willkommen im Spiel namens Gröbner Solitaire!",
                "GeoGebra lädt...",
                "Im Koordinatensystem siehst du ein paar Strecken. Suche ihre Endposition!",
                "Die Lösung überprüfen",
                "Diese Applikation wurde von <a %1$s>%2$s</a> erstellt. Das Programm basiert auf einem Spiel von %4$s und <a %5$s>%6$s</a> verfassten <a %3$s>mathematischen Artikel</a>.",
                "Die Version %1$s von GeoGebra wurde erfolgreich geladen.",
                "Auf dieser Weise kann keine Strecke entstehen, nur ein Punkt, da die grüne und rote Strecke nur durch verschieben ineinander gebracht werden können. Versuche es nochmal mit der Erstellung einer grünen Strecke.",
                "Die erhaltene Strecke existiert schon als rote Strecke. Schade! Versuche es nochmal mit der Erstellung einer grünen Strecke.",
                "Super! Du hast es geschafft, eine neue Strecke zu erstellen, da man die grüne Strecke nicht mehr weiter vereinfachen kann.",
                "Leider ist das noch nicht die Endposition! Bitte probiere es weiter.",
                "Genial! Du hast die Endposition gefunden. Gratuliere, du hast das Spiel gewonnen!"
                ];
            phase_text = ["Erstellen, 1. Schritt: Wähle zwei rote Strecken und klicke auf das entstehende blaue Rechteck. Hiermit kannst du eine grüne Strecke erzeugen.",
                "Erstellen, 2. Schritt: Fixiere die grüne Strecke, indem du draufklickst.",
                "Vereinfachen, 1. Schritt: Wähle die grüne Strecke aus, und vereinfache die grüne Strecke mit der roten Strecke (klicke drauf), dann klicke auf das entstehende blaue Rechteck.",
                "Vereinfachen, 2. Schritt: Fixiere die grüne Strecke, indem du draufklickst."
                ];
            }

        var element = document.getElementById('welcome');
        element.innerHTML = messages[MessageEnum.WELCOME];
        element = document.getElementById('geogebra_loading');
        element.innerHTML = '<p>' + messages[MessageEnum.PLEASE_WAIT] + '</p>';
        element = document.getElementById('geogebra_loaded');
        element.innerHTML = '<p>' + messages[MessageEnum.DESCRIPTION] + '</p>';
        element = document.getElementById('check_solution');
        element.innerHTML = messages[MessageEnum.CHECK_BUTTON];
        element = document.getElementById('info');
        element.innerHTML = '<p>' + sprintf(messages[MessageEnum.PROGRAM_INFO],
            'href="https://www.geogebra.org/u/zoltan" target="_blank"',
            "Zoltán Kovács",
            'href="http://dx.doi.org/10.4169/math.mag.89.4.235" target="_blank"',
            'Haley Dozier',
            'href="http://www.math.usm.edu/perry/" target="_blank"',
            'John Perry') + '</p>';

        // 1. Setup GeoGebra
        var parameters = {
            "id": "ggbApplet",
            "width": 400,
            "height": 400,
            "showToolBar": false,
            "borderColor": null,
            "showMenuBar": false,
            "allowStyleBar": false,
            "showAlgebraInput": false,
            "enableLabelDrags": false,
            "enableShiftDragZoom": true,
            "capturingThreshold": null,
            "showToolBarHelp": false,
            "errorDialogsActive": false,
            "showTutorialLink": false,
            "showLogging": true,
            "useBrowserForJS": false,
            "enableRightClick": false,
            "perspective": "G"
        };

        parameters.appletOnLoad = function (api) {
            // This code will run after the applet has been injected.
            gA = ggbApplet;
            var element = document.getElementById('geogebra_loading');
            var version = gA.getVersion();
            element.innerHTML = sprintf(messages[MessageEnum.GEOGEBRA_VERSION], version);
            var element = document.getElementById('geogebra_loaded');
            element.hidden = false;

            // 3. Create initial objects (this could be done later as well)
            gA.setBase64(startup);
            // gA.setPerspective("G");

            // 4. To do CAS computations, the CAS must be loaded somehow.
            // There are multiple ways to do that. The best way is
            // to call the CAS implicitly and the computation result is
            // collected into a dummy variable.
            gA.evalCommand("dummy=Factor(x^2+x)");
            gA.setVisible("dummy", false);
            // There is a quick result in the dummy variable, "undefined",
            // but the CAS is starting to be loaded in the background,
            // asynchronously. However, the immediate result of the command
            // is synchronous, that is, it is obtained immediately after
            // evalCommand is performed.

            // 5. Register a listener to be informed on the final result
            // when the dummy variable is computed. On the finished computation
            // the dummy variable will be updated and the listener will
            // be notified.
            gA.registerUpdateListener("go_heavy");
        };

        // 2. Inject applet
        var applet = new GGBApplet(parameters, '5.0', 'applet_container');

        // Using GeoGebra offline:
        applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
        applet.inject('applet_container');
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function output(message) {
        var outputbox = document.getElementById('outputbox');
        outputbox.innerHTML += message;
        outputbox.scrollTop = 99999;
        window.scrollTo(0, document.body.scrollHeight);
    }

    function getElapsedTime() {
        var endTime = new Date();
        var timeDiff = endTime - startTime;
        timeDiff /= 1000;
        var seconds = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var minutes = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var hours = Math.round(timeDiff % 24);
        return "Elapsed time: " + hours + "h " + minutes + "m " + seconds + "s";
    }

    function endMessage(text) {
        var restart_button = document.getElementById('restart');
        restart_button.hidden = false;
    }

    function problems() {
        P = ["x^3+1,x*y^2+y^3", "x^3+y,x+y^3", "x^2*y+1,x^2*y^2+1", "x^3*y+x^2,x^3*y+x^3,x^4*y+x^4"];
    }

    // Conversion from polynomial to array of 4 numbers
    function getexp(p) {
        if (p.length === 1) {
            if (p === "1") {  // x or y or 1
                return 0;
            }
            return 1; // x or y
        }
        // e.g. x^12
        return p.substr(2); // 12
    }

    function monom2point(m) {
        console.log("m=" + m);
        var fs = m.split("*"); // factors, e.g. x^2*y^3
        var a, b;
        if (fs.length === 1) { // x^2 or y^3
            if (fs[0].indexOf("x") === -1) {
                // it is a monom of y only
                a = 0;
                b = getexp(fs[0]);
            } else {
                // it is a monom of x only
                a = getexp(fs[0]);
                b = 0;
            }
        } else {
            a = getexp(fs[0]);
            b = getexp(fs[1]);
        }
        return [parseInt(a), parseInt(b)];
    }

    function binom2seg(p) {
        console.log("p=" + p);
        var ms = p.split("+"); // monomials, e.g. x^2*y^3+x^3*y
        var m1 = ms[0];
        var mp1 = monom2point(m1);
        var mp2;
        if (ms.length > 1) {
            var m2 = ms[1];
            mp2 = monom2point(m2);
        } else {
            mp2 = [0, 0];
        }
        return [mp1, mp2];
    }

    function ideal2quadruple(i) {
        console.log("ideal=" + i);
        var id = i.split(",");
        var q = [];
        for (var j = 0; j < id.length; j++) {
            console.log("id[" + j + "]=" + id[j]);
            twopairs = binom2seg(id[j]);
            console.log("twopairs=" + twopairs);
            q.push(twopairs.flat());
        }
        return q;
    }

    // End of conversion related functions.


    function Ax(i) {
        return p[i * 4];
    }

    function Ay(i) {
        return p[i * 4 + 1];
    }

    function Bx(i) {
        return p[i * 4 + 2];
    }

    function By(i) {
        return p[i * 4 + 3];
    }

    function create_segment(j, r, g, b) {
        var A = "A" + j;
        var command = A + "=(" + Ax(j) + "," + Ay(j) + ")";
        console.log(command);
        gA.evalCommand(command);
        var B = "B" + j;
        command = B + "=(" + Bx(j) + "," + By(j) + ")";
        console.log(command);
        gA.evalCommand(command);
        var s = "s" + j;
        gA.evalCommand(s + "=Segment(" + A + "," + B + ")");
        gA.setFixed(A, false, false);
        gA.setFixed(B, false, false);
        gA.setVisible(B, false);
        gA.setFixed(s, true, true);
        gA.setColor(s, r, g, b);
        gA.setColor(A, r, g, b);
    }

    function create_segment_anim(j, r, g, b, _Ax, _Ay, _Bx, _By) {
        var A = "A" + j;
        var command = A + "=(" + (Ax(j)-_Ax) + "*slider + " + _Ax + "," + 
            (Ay(j)-_Ay) + "*slider + " + _Ay + ")";
        console.log(command);
        gA.evalCommand(command);
        var B = "B" + j;
        command = B + "=(" + (Bx(j)-_Bx) + "*slider + " + _Bx + "," + 
            (By(j)-_By) + "*slider + " + _By + ")";
        console.log(command);
        gA.evalCommand(command);
        var s = "s" + j;
        gA.evalCommand(s + "=Segment(" + A + "," + B + ")");
        gA.setFixed(A, false, false);
        gA.setFixed(B, false, false);
        gA.setVisible(B, false);
        gA.setFixed(s, true, true);
        gA.setColor(s, r, g, b);
        gA.setColor(A, r, g, b);
    }

    async function go_heavy(object) {
        // 6. This is called when the dummy object has been updated
        // on completion of the dummy computation.
        if (object === "dummy") {
            // 7. Remove this listener to avoid re-launching this code.
            // Also remove dummy object.
            gA.unregisterUpdateListener("go_heavy");
            gA.deleteObject("dummy");
            gA.registerClickListener("on_click");
            gA.registerObjectUpdateListener("slider", "on_update_slider");
            // This also be have to set to a variable in the applet, see
            // https://help.geogebra.org/topic/hide-play-button-in-drawing-with-automated-slider
            gA.setAnimationSpeed("slider", 3);

            // 8. Start real computations. Note that all evalCommand
            // computations are synchronous, that is, from this point on
            // no asynchronous code must be written.

            var element = document.getElementById('geogebra_loading');
            element.hidden = true;
            element = document.getElementById('check_button');
            element.hidden = false;

            problems();

            var r = getQueryVariable("level");
            if (!r) {
                r = 0;
                }
            p = ideal2quadruple(P[r]).flat();
            console.log("p=" + p);
            caseval = __ggb__giac.cwrap('caseval', 'string', ['string']); // direct link to Giac
            var giaccommand = "gbasis([" + P[r] + "] mod 2,[x,y],plex)";
            var solution = caseval(giaccommand);
            console.log("giaccommand=" + giaccommand);
            solution = solution.substring(1, solution.length - 1).replace(/\-/g, "+");
            console.log("solution=" + solution);
            q = ideal2quadruple(solution);
            console.log("q=" + q);

            segs = p.length / 4;
            for (i = 0; i < segs; i++) {
                create_segment(i, 255, 0, 0);
            }
            selected = [];

            phase = 1;
            set_phase();
        }
    }

    function remove_segment(i) {
        gA.deleteObject("A" + i);
        for (var j = 0; j < 4; j++) {
            p[4 * i + j] = -1; // TODO: find a more elegant way
        }
    }

    function existing_segment(i) {
        return Ax(i) >= 0 && Ay(i) >= 0 && Bx(i) >= 0 && By(i) >= 0;
    }

    function set_phase() {
        var element = document.getElementById('phase');
        element.innerHTML = phase_text[phase-1];
        element = document.getElementById('check_solution');
        if (phase === 1) {
            element.disabled = false;
        } else {
            element.disabled = true;
        }
    }

    function initialize_segment(j) {
        gA.setColor("s" + j, 255, 0, 0);
        gA.setColor("A" + j, 255, 0, 0);
        gA.setFixed("s" + j, true, true);
    }

    function remove_ineqs() {
        for (i = 0; i < 2; i++) {
            gA.deleteObject("i" + selected[i]);
        }
        selected = [];
    }

    function on_update_slider(object) {
        if (gA.getValue("slider") < 0.9) {
        // We cannot trigger the last update, so we need to use this dirty hack here.
        // if (gA.isAnimationRunning()) {
           console.log("wait for the animation to finish");
           return;
           }

        console.log("end of animation");

        if (phase === 1.5 || phase === 3.5) {
            phase += 0.5;
            gA.stopAnimation();
            create_segment(segs-2, 128, 128, 128);
            gA.setFixed("s" + (segs-2), false, false);
            create_segment(segs-1, 128, 128, 128);
            gA.setFixed("s" + (segs-1), false, false);

            create_segment(segs, 0, 255, 0);
            gA.setLayer("s" + segs, 5);
            if (phase === 4) { // reduction
                remove_segment(segs - 3);
            }
            segs++;
            set_phase();
            gA.setValue("slider", 0);

            remove_ineqs();

            // For some reason, the listeners stop when the animation stops.
            // So we need to recreate them:
            gA.registerClickListener("on_click");
            gA.registerObjectUpdateListener("slider", "on_update_slider");
        }
    }

    function on_click(object) {

        var i;
        var t = gA.getObjectType(object);

        console.log(object + " type is " + t + ", phase = " + phase);

        if (t === "inequality") { // we are in generation or reduction
            if (selected.length === 2) {
                var A0x = Ax(selected[0]);
                var A1x = Ax(selected[1]);
                var A0y = Ay(selected[0]);
                var A1y = Ay(selected[1]);
                var B0x = Bx(selected[0]);
                var B1x = Bx(selected[1]);
                var B0y = By(selected[0]);
                var B1y = By(selected[1]);

                var Cx = Math.max(A0x, A1x);
                var Cy = Math.max(A0y, A1y);
                var Dx = -A0x + B0x + Cx; // Cx-Dx=Ax-Bx
                var Dy = -A0y + B0y + Cy; // Cy-Dy=Ay-By
                var Ex = -A1x + B1x + Cx;
                var Ey = -A1y + B1y + Cy;

                var Gx, Gy, Hx, Hy;
                // order lexicographically:
                if (Dx > Ex) {
                    Gx = Dx;
                    Gy = Dy;
                    Hx = Ex;
                    Hy = Ey;
                } else {
                    if (Dx < Ex) {
                        Gx = Ex;
                        Gy = Ey;
                        Hx = Dx;
                        Hy = Dy;
                    } else { // Dx==Ex
                        if (Dy > Ey) {
                            Gx = Dx;
                            Gy = Dy;
                            Hx = Ex;
                            Hy = Ey;
                        } else {
                            if (Dy < Ey) {
                                Gx = Ex;
                                Gy = Ey;
                                Hx = Dx;
                                Hy = Dy;
                            } else {
                                console.log("Nothing is generated. Dx=" + Dx + " Dy=" + Dy + " Ex=" + Ex + " Ey=" + Ey);
                                alert(messages[MessageEnum.NOTHING_GENERATED]);
                                remove_ineqs();
                                remove_segment(segs - 1);
                                phase = 1;
                                set_phase();
                                for (i = 0; i < segs - 1; i++) {
                                    initialize_segment(i);
                                }
                                return; // nothing is generated
                            }
                        }
                    }
                }

                console.log("Generated segment should be (" + Gx + "," + Gy + ")-(" + Hx + "," + Hy + ")");
                for (i = 0; i < segs; i++) {
                    if (Gx === Ax(i) && Gy === Ay(i) && Hx === Bx(i) && Hy === By(i)) { // this segment already exists
                        console.log("Already exists as s" + i);
                        alert(messages[MessageEnum.ALREADY_EXISTS]);
                        remove_ineqs();
                        remove_segment(segs - 1);
                        phase = 1;
                        set_phase();
                        for (i = 0; i < segs - 1; i++) {
                            initialize_segment(i);
                        }

                        return;
                    }
                }

                p.push(Cx, Cy, Dx, Dy);
                console.log(p);
                create_segment_anim(segs, 128, 128, 128, A0x, A0y, B0x, B0y);
                gA.setFixed("s" + segs, false, false);
                segs++;
                p.push(Cx, Cy, Ex, Ey);
                console.log(p);
                create_segment_anim(segs, 128, 128, 128, A1x, A1y, B1x, B1y);
                gA.setFixed("s" + segs, false, false);
                segs++;
                p.push(Gx, Gy, Hx, Hy);
                console.log(p);
                phase += 0.5;
                gA.evalCommand("StartAnimation(slider)");
                if ((Cx == A0x) && (Cy == A0y) && (Cx == A1x) && (Cy == A1y)) {
                    gA.setAnimationSpeed("slider", 30);
                    } else {
                    gA.setAnimationSpeed("slider", 3);
                    }
                return;
            }
        }

        set_phase();

        if (t !== "segment") {
            return;
        }

        console.log(object + " changed");

        if (phase === 2 || phase === 4) { // generation, end
            i = parseInt(object.substring(1));
            if (i === segs - 1) { // this is the generated segment
                remove_segment(i - 1);
                remove_segment(i - 2);
                gA.setColor("s" + i, 0, 255, 0);
                gA.setColor("A" + i, 0, 255, 0);
                phase = 3; // start reduction
                set_phase();
                var allowed = 0;
                for (i = 0; i < segs - 1; i++) {
                    if (Ax(i) > Ax(segs - 1) || Ay(i) > Ay(segs - 1)) {
                        // disable segments that are in the wrong direction:
                        gA.setColor("s" + i, 64, 0, 0);
                        gA.setColor("A" + i, 64, 0, 0);
                        gA.setFixed("s" + i, false, false);
                    } else if (existing_segment(i)) {
                        // eventually re-allow segments from the previous reduction step:
                        initialize_segment(i);
                        allowed++;
                    }
                }
                if (allowed === 0) { // end of reduction
                    for (i = 0; i < segs - 1; i++) {
                        initialize_segment(i);
                    }
                    gA.setColor("s" + (segs - 1), 255, 0, 0);
                    gA.setColor("A" + (segs - 1), 255, 0, 0);
                    phase = 1;
                    set_phase();
                    alert(messages[MessageEnum.NEW_SEGMENT]);
                    return;
                }
            }
        }

        if (phase === 1 || phase === 3) { // generation or reduction
            if (selected.length < 2) {
                console.log("selected=" + selected);
                i = parseInt(object.substring(1));
                if (selected.includes(i)) {
                    gA.deleteObject("i" + i);
                    for (var j = selected.length - 1; j >= 0; j--) {
                        if (selected[j] === i) {
                            selected.splice(j, 1);
                        }
                    }
                    return;
                }
                var command = "i" + i + "=(x>=" + Ax(i) + " && y>=" + Ay(i) + ")";
                gA.evalCommand(command);
                selected.push(i);
                return;
            }
        }
    }

    function check_solution() {
        for (var i = 0; i < q.length; i++) {
            found = false;
            var j = 0;
            while (j < segs && !found) {
                if (existing_segment(j) && q[i][0] === Ax(j) && q[i][1] === Ay(j)
                    && q[i][2] === Bx(j) && q[i][3] === By(j)) {
                    found = true;
                }
                j++;
            }
            if (!found) {
                alert(messages[MessageEnum.UNFINISHED]);
                return;
            }
        }
        alert(messages[MessageEnum.FINISHED]);
    }

</script>

</body>
</html>

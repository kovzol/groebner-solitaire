<html>

<head>
    <title>Gr√∂bner Solitaire</title>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <link href="../pagestyle.css" type="text/css" rel="stylesheet">

</head>
<body onload="go()">

<div>
    <h1><div id="welcome"></div></h1>
    <div id="geogebra_loading"></div>
    <div id="geogebra_loaded" hidden="true">
    </div>
    <div id="check_button" hidden="true">
        <p><button id="check_solution" type="button" onclick="check_solution()"></button></p>
    </div>
    <div id="applet_container"></div>
    <div id="phase"></div>
    <div id="info"></div>
</div>

<script type="text/javascript" src="deployggb.js"></script>
<script type="text/javascript" src="sprintf.js"></script>

<script type='text/javascript'>

    startup = "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";

    MessageEnum = {
        WELCOME: 0, PLEASE_WAIT: 1, DESCRIPTION: 2, CHECK_BUTTON: 3, PROGRAM_INFO: 4, GEOGEBRA_VERSION: 5,
        NOTHING_GENERATED_GREEN_RED: 6, NOTHING_GENERATED_RED_RED: 7, ALREADY_EXISTS: 8, NEW_SEGMENT: 9, UNFINISHED: 10, FINISHED: 11
        };

    // https://css-tricks.com/snippets/javascript/get-url-variables/
    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            if (pair[0] == variable) {
                return pair[1];
            }
        }
        return false;
    }


    function go() {

        running = false;

        var lang = getQueryVariable("lang");
        if (!lang) {
            lang = "English";
            }

        // 0. Internationalize initial texts
        if (lang === "English") {
            messages = [ "Welcome to the Gr√∂bner Solitaire!",
                "Please wait for GeoGebra to load...",
                "Consider this initial position of the segments. Try to obtain the final position.",
                "Check solution",
                "This web app was programmed by <a %1$s>%2$s</a> based on the game described in <a %3$s>an article</a> by %4$s and <a %5$s>%6$s</a>.",
                "Using GeoGebra %1$s.",
                "No segment is generated in this way, just a point, because the green and red segments are congruent. Please try again and generate a new green segment.",
                "No segment is generated in this way, just a point, because the red segments are congruent. Please try again.",
                "The segment you obtained already exists as a red segment. Too bad! Please try again and generate a new green segment.",
                "Great! You created a new segment since no further reduction is possible for the green segment.",
                "Sorry, you did not find the final position yet! Please continue.",
                "Great! You found the final position. You win."
                ];
            phase_text = ["Generation phase 1: Select two red segments and click on the blue area to generate a green segment.",
                "Generation phase 2: Finalize the generated green segment by clicking on it.",
                "Reduction phase 1: Keep the green segment selected and reduce it by a red segment by clicking on it, then click on the blue area for reduction.",
                "Reduction phase 2: Confirm the reduced green segment by clicking on it."
                ];
            }

        if (lang === "Hungarian") {
            messages = [ "K√∂sz√∂nt√ºnk a Gr√∂bner Solitaire j√°t√©kban!",
                "A GeoGebra bet√∂lt√©se folyamatban...",
                "A j√°t√©kt√°bl√°n n√©h√°ny szakaszt l√°tsz. Keresd meg a v√©gs≈ë poz√≠ci√≥jukat!",
                "A megold√°s ellen≈ërz√©se",
                "Ezt a webalkalmaz√°st <a %1$s>Kov√°cs Zolt√°n</a> k√©sz√≠tette. A program egy %4$s √©s <a %5$s>%6$s</a> √°ltal √≠rt <a %3$s>matematikai t√°rgy√∫ cikkben</a> bemutatott j√°t√©kon alapul.",
                "A GeoGebra %1$s verzi√≥j√°nak bet√∂lt√©se siker√ºlt.",
                "Nem keletkezett szakasz ily m√≥don, csup√°n egy pont, mivel a z√∂ld √©s piros szakaszok eltol√°ssal egym√°sba vihet≈ëk. Pr√≥b√°ld √∫jra egy √∫j z√∂ld szakasz l√©trehoz√°s√°val!",
                "Nem keletkezett szakasz ily m√≥don, csup√°n egy pont, mivel piros szakaszok eltol√°ssal egym√°sba vihet≈ëk. Pr√≥b√°ld √∫jra!",
                "A kapott szakasz m√°r l√©tezik mint piros szakasz. K√°r! Pr√≥b√°ld √∫jra egy √∫j z√∂ld szakasz l√©trehoz√°s√°val!",
                "Nagyszer≈±! Siker√ºlt l√©trehoznod egy √∫j szakaszt, mivel a z√∂ld szakasz tov√°bb m√°r nem egyszer≈±s√≠thet≈ë.",
                "Sajnos ez m√©g nem a v√©gs≈ë poz√≠ci√≥! K√©rlek folytasd a j√°t√©kot tov√°bb!",
                "Nagyszer≈±! Megtal√°ltad a v√©gs≈ë poz√≠ci√≥t. Nyert√©l!"
                ];
            phase_text = ["L√©trehoz√°s, 1. l√©p√©s: V√°lassz k√©t piros szakaszt √©s kattints a k√©k ter√ºletre! √çgy l√©trehozhatsz egy z√∂ld szakaszt.",
                "L√©trehoz√°s, 2. l√©p√©s: R√∂gz√≠tsd a z√∂ld szakaszt √∫gy, hogy r√°kattintasz.",
                "Egyszer≈±s√≠t√©s, 1. l√©p√©s: Legyen a z√∂ld szakasz kiv√°lasztva, √©s egyszer≈±s√≠tsd a z√∂ld szakaszt egy piros szakasszal (kattints r√°), majd kattints a l√©trej√∂v≈ë k√©k ter√ºletre.",
                "Egyszer≈±s√≠t√©s, 2. l√©p√©s: R√∂gz√≠tsd a z√∂ld szakaszt √∫gy, hogy r√°kattintasz."
                ];
            }

        if (lang === "German") {
            messages = [ "Willkommen im Spiel namens Gr√∂bner Solitaire!",
                "GeoGebra l√§dt...",
                "Im Koordinatensystem siehst du ein paar Strecken. Suche ihre Endposition!",
                "Die L√∂sung √ºberpr√ºfen",
                "Diese Applikation wurde von <a %1$s>%2$s</a> erstellt. Das Programm basiert auf einem Spiel von %4$s und <a %5$s>%6$s</a> verfassten <a %3$s>mathematischen Artikel</a>.",
                "Die Version %1$s von GeoGebra wurde erfolgreich geladen.",
                "Auf dieser Weise kann keine Strecke entstehen, nur ein Punkt, da die gr√ºne und rote Strecke nur durch verschieben ineinander gebracht werden k√∂nnen. Versuche es nochmal mit der Erstellung einer gr√ºnen Strecke.",
                "Auf dieser Weise kann keine Strecke entstehen, nur ein Punkt, da die roten Strecken nur durch verschieben ineinander gebracht werden k√∂nnen. Versuche es nochmal.",
                "Die erhaltene Strecke existiert schon als rote Strecke. Schade! Versuche es nochmal mit der Erstellung einer gr√ºnen Strecke.",
                "Super! Du hast es geschafft, eine neue Strecke zu erstellen, da man die gr√ºne Strecke nicht mehr weiter vereinfachen kann.",
                "Leider ist das noch nicht die Endposition! Bitte probiere es weiter.",
                "Genial! Du hast die Endposition gefunden. Gratuliere, du hast das Spiel gewonnen!"
                ];
            phase_text = ["Erstellen, 1. Schritt: W√§hle zwei rote Strecken und klicke auf das entstehende blaue Rechteck. Hiermit kannst du eine gr√ºne Strecke erzeugen.",
                "Erstellen, 2. Schritt: Fixiere die gr√ºne Strecke, indem du draufklickst.",
                "Vereinfachen, 1. Schritt: W√§hle die gr√ºne Strecke aus, und vereinfache die gr√ºne Strecke mit der roten Strecke (klicke drauf), dann klicke auf das entstehende blaue Rechteck.",
                "Vereinfachen, 2. Schritt: Fixiere die gr√ºne Strecke, indem du draufklickst."
                ];
            }

        var element = document.getElementById('welcome');
        element.innerHTML = messages[MessageEnum.WELCOME];
        element = document.getElementById('geogebra_loading');
        element.innerHTML = '<p>' + messages[MessageEnum.PLEASE_WAIT] + '</p>';
        element = document.getElementById('geogebra_loaded');
        element.innerHTML = '<p>' + messages[MessageEnum.DESCRIPTION] + '</p>';
        element = document.getElementById('check_solution');
        element.innerHTML = messages[MessageEnum.CHECK_BUTTON];
        element = document.getElementById('info');
        element.innerHTML = '<p>' + sprintf(messages[MessageEnum.PROGRAM_INFO],
            'href="https://www.geogebra.org/u/zoltan" target="_blank"',
            "Zolt√°n Kov√°cs",
            'href="http://dx.doi.org/10.4169/math.mag.89.4.235" target="_blank"',
            'Haley Dozier',
            'href="http://www.math.usm.edu/perry/" target="_blank"',
            'John Perry') + '</p>';

        // 1. Setup GeoGebra
        var parameters = {
            "id": "ggbApplet",
            "width": 400,
            "height": 400,
            "showToolBar": false,
            "borderColor": null,
            "showMenuBar": false,
            "allowStyleBar": false,
            "showAlgebraInput": false,
            "enableLabelDrags": false,
            "enableShiftDragZoom": true,
            "capturingThreshold": null,
            "showToolBarHelp": false,
            "errorDialogsActive": false,
            "showTutorialLink": false,
            "showLogging": true,
            "useBrowserForJS": false,
            "enableRightClick": false,
            "perspective": "G"
        };

        parameters.appletOnLoad = function (api) {
            // This code will run after the applet has been injected.
            gA = ggbApplet;
            var element = document.getElementById('geogebra_loading');
            var version = gA.getVersion();
            element.innerHTML = sprintf(messages[MessageEnum.GEOGEBRA_VERSION], version);
            var element = document.getElementById('geogebra_loaded');
            element.hidden = false;

            // 3. Create initial objects (this could be done later as well)
            gA.setBase64(startup);
            // gA.setPerspective("G");

            // 4. To do CAS computations, the CAS must be loaded somehow.
            // There are multiple ways to do that. The best way is
            // to call the CAS implicitly and the computation result is
            // collected into a dummy variable.
            gA.evalCommand("dummy=Factor(x^2+x)");
            gA.setVisible("dummy", false);
            // There is a quick result in the dummy variable, "undefined",
            // but the CAS is starting to be loaded in the background,
            // asynchronously. However, the immediate result of the command
            // is synchronous, that is, it is obtained immediately after
            // evalCommand is performed.

            // 5. Register a listener to be informed on the final result
            // when the dummy variable is computed. On the finished computation
            // the dummy variable will be updated and the listener will
            // be notified.
            gA.registerUpdateListener("go_heavy");
        };

        // 2. Inject applet
        var applet = new GGBApplet(parameters, '5.0', 'applet_container');

        // Using GeoGebra offline:
        applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web/');
        applet.inject('applet_container');
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function output(message) {
        var outputbox = document.getElementById('outputbox');
        outputbox.innerHTML += message;
        outputbox.scrollTop = 99999;
        window.scrollTo(0, document.body.scrollHeight);
    }

    function getElapsedTime() {
        var endTime = new Date();
        var timeDiff = endTime - startTime;
        timeDiff /= 1000;
        var seconds = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var minutes = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var hours = Math.round(timeDiff % 24);
        return "Elapsed time: " + hours + "h " + minutes + "m " + seconds + "s";
    }

    function endMessage(text) {
        var restart_button = document.getElementById('restart');
        restart_button.hidden = false;
    }

    function problems() {
        P = ["x^3+1,x*y^2+y^3", "x^3+y,x+y^3", "x^2*y+1,x^2*y^2+1", "x^3*y+x^2,x^3*y+x^3,x^4*y+x^4"];
    }

    // Conversion from polynomial to array of 4 numbers
    function getexp(p) {
        if (p.length === 1) {
            if (p === "1") {  // x or y or 1
                return 0;
            }
            return 1; // x or y
        }
        // e.g. x^12
        return p.substr(2); // 12
    }

    function monom2point(m) {
        console.log("m=" + m);
        var fs = m.split("*"); // factors, e.g. x^2*y^3
        var a, b;
        if (fs.length === 1) { // x^2 or y^3
            if (fs[0].indexOf("x") === -1) {
                // it is a monom of y only
                a = 0;
                b = getexp(fs[0]);
            } else {
                // it is a monom of x only
                a = getexp(fs[0]);
                b = 0;
            }
        } else {
            a = getexp(fs[0]);
            b = getexp(fs[1]);
        }
        return [parseInt(a), parseInt(b)];
    }

    function binom2seg(p) {
        console.log("p=" + p);
        var ms = p.split("+"); // monomials, e.g. x^2*y^3+x^3*y
        var m1 = ms[0];
        var mp1 = monom2point(m1);
        var mp2;
        if (ms.length > 1) {
            var m2 = ms[1];
            mp2 = monom2point(m2);
        } else {
            mp2 = [0, 0];
        }
        return [mp1, mp2];
    }

    function ideal2quadruple(i) {
        console.log("ideal=" + i);
        var id = i.split(",");
        var q = [];
        for (var j = 0; j < id.length; j++) {
            console.log("id[" + j + "]=" + id[j]);
            twopairs = binom2seg(id[j]);
            console.log("twopairs=" + twopairs);
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
            twopairs = twopairs.reduce((acc, val) => acc.concat(val), []);
            q.push(twopairs);
        }
        return q;
    }

    // End of conversion related functions.


    function Ax(i) {
        return p[i * 4];
    }

    function Ay(i) {
        return p[i * 4 + 1];
    }

    function Bx(i) {
        return p[i * 4 + 2];
    }

    function By(i) {
        return p[i * 4 + 3];
    }

    function create_segment(j, r, g, b) {
        var A = "A" + j;
        var command = A + "=(" + Ax(j) + "," + Ay(j) + ")";
        console.log(command);
        gA.evalCommand(command);
        var B = "B" + j;
        command = B + "=(" + Bx(j) + "," + By(j) + ")";
        console.log(command);
        gA.evalCommand(command);
        var s = "s" + j;
        gA.evalCommand(s + "=Segment(" + A + "," + B + ")");
        gA.setFixed(A, false, false);
        gA.setFixed(B, false, false);
        gA.setVisible(B, false);
        gA.setFixed(s, true, true);
        gA.setColor(s, r, g, b);
        gA.setColor(A, r, g, b);
    }

    function create_segment_anim(j, r, g, b, _Ax, _Ay, _Bx, _By) {
        var A = "A" + j;
        var command = A + "=(" + (Ax(j)-_Ax) + "*slider + " + _Ax + "," + 
            (Ay(j)-_Ay) + "*slider + " + _Ay + ")";
        console.log(command);
        gA.evalCommand(command);
        var B = "B" + j;
        command = B + "=(" + (Bx(j)-_Bx) + "*slider + " + _Bx + "," + 
            (By(j)-_By) + "*slider + " + _By + ")";
        console.log(command);
        gA.evalCommand(command);
        var s = "s" + j;
        gA.evalCommand(s + "=Segment(" + A + "," + B + ")");
        gA.setFixed(A, false, false);
        gA.setFixed(B, false, false);
        gA.setVisible(B, false);
        gA.setFixed(s, true, true);
        gA.setColor(s, r, g, b);
        gA.setColor(A, r, g, b);
    }

    async function go_heavy(object) {
        // 6. This is called when the dummy object has been updated
        // on completion of the dummy computation.
        if (object === "dummy") {
            // 7. Remove this listener to avoid re-launching this code.
            // Also remove dummy object.
            gA.unregisterUpdateListener("go_heavy");
            gA.deleteObject("dummy");
            gA.registerClickListener("on_click");
            gA.registerObjectUpdateListener("slider", "on_update_slider");
            // This also be have to set to a variable in the applet, see
            // https://help.geogebra.org/topic/hide-play-button-in-drawing-with-automated-slider
            gA.setAnimationSpeed("slider", 3);

            // 8. Start real computations. Note that all evalCommand
            // computations are synchronous, that is, from this point on
            // no asynchronous code must be written.

            var element = document.getElementById('geogebra_loading');
            element.hidden = true;
            element = document.getElementById('check_button');
            element.hidden = false;

            problems();

            var r = getQueryVariable("level");
            if (!r) {
                r = 0;
                }
            p = ideal2quadruple(P[r]);
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
            p = p.reduce((acc, val) => acc.concat(val), []);
            console.log("p=" + p);
            caseval = __ggb__giac.cwrap('caseval', 'string', ['string']); // direct link to Giac
            var giaccommand = "gbasis([" + P[r] + "] mod 2,[x,y],plex)";
            var solution = caseval(giaccommand);
            console.log("giaccommand=" + giaccommand);
            solution = solution.substring(1, solution.length - 1).replace(/\-/g, "+");
            console.log("solution=" + solution);
            q = ideal2quadruple(solution);
            console.log("q=" + q);

            segs = p.length / 4;
            for (i = 0; i < segs; i++) {
                create_segment(i, 255, 0, 0);
            }
            selected = [];

            phase = 1;
            set_phase();
        }
    }

    function remove_segment(i) {
        gA.deleteObject("A" + i);
        for (var j = 0; j < 4; j++) {
            p[4 * i + j] = -1; // TODO: find a more elegant way
        }
    }

    function existing_segment(i) {
        return Ax(i) >= 0 && Ay(i) >= 0 && Bx(i) >= 0 && By(i) >= 0;
    }

    function set_phase() {
        phase_int = Math.floor(phase);
        var element = document.getElementById('phase');
        element.innerHTML = phase_text[phase_int-1];
        element = document.getElementById('check_solution');
        if (phase_int === 1) {
            element.disabled = false;
        } else {
            element.disabled = true;
        }
    }

    function initialize_segment(j) {
        gA.setColor("s" + j, 255, 0, 0);
        gA.setColor("A" + j, 255, 0, 0);
        gA.setFixed("s" + j, true, true);
    }

    function remove_ineqs() {
        for (i = 0; i < 2; i++) {
            gA.deleteObject("i" + selected[i]);
        }
        selected = [];
    }

    function on_update_slider(object) {
        if (gA.getValue("slider") < 0.9) {
        // We cannot trigger the last update, so we need to use this dirty hack here.
        // if (gA.isAnimationRunning()) {
           console.log("wait for the animation to finish");
           return;
           }

        console.log("end of animation");

        if (phase === 1.5 || phase === 3.5) {
            phase += 0.5;
            gA.stopAnimation();
            create_segment(segs-2, 128, 128, 128);
            gA.setFixed("s" + (segs-2), false, false);
            create_segment(segs-1, 128, 128, 128);
            gA.setFixed("s" + (segs-1), false, false);

            create_segment(segs, 0, 255, 0);
            gA.setLayer("s" + segs, 5);
            if (phase === 4) { // reduction
                remove_segment(segs - 3);
            }
            segs++;
            set_phase();
            gA.setValue("slider", 0);

            remove_ineqs();

            // For some reason, the listeners stop when the animation stops.
            // So we need to recreate them:
            gA.registerClickListener("on_click");
            gA.registerObjectUpdateListener("slider", "on_update_slider");
        }
    }

    function on_click(object) {

        var i;
        var t = gA.getObjectType(object);

        console.log(object + " type is " + t + ", phase = " + phase);

        if (t === "inequality" && phase != 1.5 && phase != 3.5) { // we are in generation or reduction
            if (selected.length === 2) {
                var A0x = Ax(selected[0]);
                var A1x = Ax(selected[1]);
                var A0y = Ay(selected[0]);
                var A1y = Ay(selected[1]);
                var B0x = Bx(selected[0]);
                var B1x = Bx(selected[1]);
                var B0y = By(selected[0]);
                var B1y = By(selected[1]);

                var Cx = Math.max(A0x, A1x);
                var Cy = Math.max(A0y, A1y);
                var Dx = -A0x + B0x + Cx; // Cx-Dx=Ax-Bx
                var Dy = -A0y + B0y + Cy; // Cy-Dy=Ay-By
                var Ex = -A1x + B1x + Cx;
                var Ey = -A1y + B1y + Cy;

                var Gx, Gy, Hx, Hy;
                // order lexicographically:
                if (Dx > Ex) {
                    Gx = Dx;
                    Gy = Dy;
                    Hx = Ex;
                    Hy = Ey;
                } else {
                    if (Dx < Ex) {
                        Gx = Ex;
                        Gy = Ey;
                        Hx = Dx;
                        Hy = Dy;
                    } else { // Dx==Ex
                        if (Dy > Ey) {
                            Gx = Dx;
                            Gy = Dy;
                            Hx = Ex;
                            Hy = Ey;
                        } else {
                            if (Dy < Ey) {
                                Gx = Ex;
                                Gy = Ey;
                                Hx = Dx;
                                Hy = Dy;
                            } else {
                                console.log("Nothing is generated. Dx=" + Dx + " Dy=" + Dy + " Ex=" + Ex + " Ey=" + Ey);
                                if (phase == 1) {
                                    alert(messages[MessageEnum.NOTHING_GENERATED_RED_RED]);
                                } else {
                                    alert(messages[MessageEnum.NOTHING_GENERATED_GREEN_RED]);
                                    remove_segment(segs - 1);
                                }
                                remove_ineqs();
                                phase = 1;
                                set_phase();
                                for (i = 0; i < segs - 1; i++) {
                                    initialize_segment(i);
                                }
                                return; // nothing is generated
                            }
                        }
                    }
                }

                console.log("Generated segment should be (" + Gx + "," + Gy + ")-(" + Hx + "," + Hy + ")");
                for (i = 0; i < segs; i++) {
                    if (Gx === Ax(i) && Gy === Ay(i) && Hx === Bx(i) && Hy === By(i)) { // this segment already exists
                        console.log("Already exists as s" + i);
                        alert(messages[MessageEnum.ALREADY_EXISTS]);
                        remove_ineqs();
                        remove_segment(segs - 1);
                        phase = 1;
                        set_phase();
                        for (i = 0; i < segs - 1; i++) {
                            initialize_segment(i);
                        }

                        return;
                    }
                }

                p.push(Cx, Cy, Dx, Dy);
                console.log(p);
                create_segment_anim(segs, 128, 128, 128, A0x, A0y, B0x, B0y);
                gA.setFixed("s" + segs, false, false);
                segs++;
                p.push(Cx, Cy, Ex, Ey);
                console.log(p);
                create_segment_anim(segs, 128, 128, 128, A1x, A1y, B1x, B1y);
                gA.setFixed("s" + segs, false, false);
                segs++;
                p.push(Gx, Gy, Hx, Hy);
                console.log(p);
                phase += 0.5;
                gA.evalCommand("StartAnimation(slider)");
                if ((Cx == A0x) && (Cy == A0y) && (Cx == A1x) && (Cy == A1y)) {
                    gA.setAnimationSpeed("slider", 30);
                    } else {
                    gA.setAnimationSpeed("slider", 3);
                    }
                return;
            }
        }

        set_phase();

        if (t !== "segment") {
            return;
        }

        console.log(object + " changed");

        if (phase === 2 || phase === 4) { // generation, end
            i = parseInt(object.substring(1));
            if (i === segs - 1) { // this is the generated segment
                remove_segment(i - 1);
                remove_segment(i - 2);
                gA.setColor("s" + i, 0, 255, 0);
                gA.setColor("A" + i, 0, 255, 0);
                phase = 3; // start reduction
                set_phase();
                var allowed = 0;
                for (i = 0; i < segs - 1; i++) {
                    if (Ax(i) > Ax(segs - 1) || Ay(i) > Ay(segs - 1)) {
                        // disable segments that are in the wrong direction:
                        gA.setColor("s" + i, 64, 0, 0);
                        gA.setColor("A" + i, 64, 0, 0);
                        gA.setFixed("s" + i, false, false);
                    } else if (existing_segment(i)) {
                        // eventually re-allow segments from the previous reduction step:
                        initialize_segment(i);
                        allowed++;
                    }
                }
                if (allowed === 0) { // end of reduction
                    for (i = 0; i < segs - 1; i++) {
                        initialize_segment(i);
                    }
                    gA.setColor("s" + (segs - 1), 255, 0, 0);
                    gA.setColor("A" + (segs - 1), 255, 0, 0);
                    phase = 1;
                    set_phase();
                    alert(messages[MessageEnum.NEW_SEGMENT]);
                    return;
                }
            }
        }

        if (phase === 1 || phase === 3) { // generation or reduction
            if (selected.length < 2) {
                console.log("selected=" + selected);
                i = parseInt(object.substring(1));
                if (selected.includes(i)) {
                    gA.deleteObject("i" + i);
                    for (var j = selected.length - 1; j >= 0; j--) {
                        if (selected[j] === i) {
                            selected.splice(j, 1);
                        }
                    }
                    return;
                }
                var command = "i" + i + "=(x>=" + Ax(i) + " && y>=" + Ay(i) + ")";
                gA.evalCommand(command);
                selected.push(i);
                return;
            }
        }
    }

    function check_solution() {
        for (var i = 0; i < q.length; i++) {
            found = false;
            var j = 0;
            while (j < segs && !found) {
                if (existing_segment(j) && q[i][0] === Ax(j) && q[i][1] === Ay(j)
                    && q[i][2] === Bx(j) && q[i][3] === By(j)) {
                    found = true;
                }
                j++;
            }
            if (!found) {
                alert(messages[MessageEnum.UNFINISHED]);
                return;
            }
        }
        alert(messages[MessageEnum.FINISHED]);
    }

</script>

</body>
</html>
